/*
 * gates.c: Implementation of gates.h header.
 * @author: rmNULL
 * Version: 0.8
 * LICENSE: MIT, refer LICENSE for more.
 * Description: see README file.
 * credits: see README.
 */
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ds/slist.h"
#include "gates.h"

/* default gate input method */
#define NUL '\0'

struct gate_input_t {
	union {
		bool pin;

		struct {
			struct gate *gate;
			int pin;
		} from;
	} ip;
	char type;
};

struct gate {
	char *name;
	int class;

	int current_pin;
	size_t set_pins;
	size_t total_pins;
	struct gate_input_t *pins;

	/* keeps track of unpinned slots. */
	SListEntry *unset_slots;

	bool op;
};

/*
 * mallocs a given ptr with size, exits on allocation failure. These kinds of exits are
 * not safe and are potential culprits of memory leaks. So, finding an
 * alternative to this method tops our TO-DO list.
 */
#define ALLOC_WITH_FAILURE_EXIT(ptr, size) do {\
	(ptr) = malloc(size); \
	if ((ptr) == NULL) { \
		/* yet to decide what needs to be done here. for now
		 * let's exit. */ \
		perror("AllocationError"); \
		exit(EXIT_FAILURE); \
	}\
} while(0)

/* checks if all the input pins of the given gate are set. */
#define ARE_PINS_SET(gate) ((gate->set_pins) == (gate->total_pins))

/* this need to be called after dealing with gate.
 * CALLING THIS IS MANDATORY.
 */
void cleanup(struct gate *gate)
{
	while (gate->unset_slots) {
		free(slist_data(gate->unset_slots));
		slist_remove_entry(&gate->unset_slots, gate->unset_slots);
	}

	if (gate->name) free(gate->name);
	if (gate->pins) free(gate->pins);
	if (gate) free(gate);
}


/* mdfn: macro defined function(s).
 * macro to (auto) define functions for creation of gates.
 *
 * defines a function with gatename as the return type and taking total_ip_pins
 * as the argument; Minimum of 2 input pins need to be present. Returns NULL on
 * failure.
 */
#define mdfn(gatename, cls) \
gatename create_##gatename##_gate(char *tag, size_t total_ip_pins) { \
	gatename gate;\
	if (total_ip_pins < 2 || total_ip_pins > 64) {\
		fprintf(stderr, "Error: Unable to create [%s %s] gate.", tag, gate_names[cls]);\
		fprintf(stderr, " %lu not in range [2..64].\n", total_ip_pins);\
		return NULL;\
	}\
	ALLOC_WITH_FAILURE_EXIT(gate, sizeof(struct gate));\
	ALLOC_WITH_FAILURE_EXIT(gate->pins, sizeof(struct gate_input_t) * total_ip_pins); \
	gate->total_pins = total_ip_pins; \
	gate->op = false; \
	gate->current_pin = 0; \
	gate->set_pins = 0;\
	gate->unset_slots = NULL;\
	gate->class = cls;\
	/*
	 * let all the gates have no type(NUL) by default. This is done
	 * to safeguard the shorted input pins. At the cost of checking at
	 * every assignment.
	 */ \
	for (int i = 0; i < total_ip_pins; ++i) { \
		gate->pins[i].type = NUL; \
	}\
	size_t len = strnlen(tag, 31) + 1; /* +1 for the NUL byte. */ \
	ALLOC_WITH_FAILURE_EXIT(gate->name, sizeof(char) * len);\
	strncpy(gate->name, tag, len);\
	return gate; \
}

/*
 * Semi-colons are not suffixed to maintain compatibilty with ISO C(sorry).
 *
 * e.g: defines a function for creating And gate of the form, (And Gate Example)
 *  Æ’: And create_And_gate(char *gate_name, size_t total_ip_pins);
 */
mdfn(And, AND)
mdfn(Or, OR)
mdfn(Xor, XOR)
mdfn(Xnor, XNOR)
mdfn(Nor, NOR)
mdfn(Nand, NAND)
#undef mdfn

/*
 * This function is not auto-generated by mdfn(macro) because
 * Not gate stands out from the crowd as it doesn't have variable number of
 * input pins. Maybe do a dirty hack and patch it in there, maybe?
 */
Not create_Not_gate(char *tag)
{
	Not gate;
	ALLOC_WITH_FAILURE_EXIT(gate, sizeof(struct gate));
	ALLOC_WITH_FAILURE_EXIT(gate->pins, sizeof(struct gate_input_t));

	gate->pins[0].type = NUL;
	size_t len = strnlen(tag, 31) + 1; /* +1 for the NUL byte. */
	ALLOC_WITH_FAILURE_EXIT(gate->name, sizeof(char) * len);
	strncpy(gate->name, tag, len);

	gate->total_pins = 1;
	gate->op = false;
	gate->current_pin = 0;
	gate->set_pins = 0;
	gate->unset_slots = NULL;
	gate->class = NOT;

	return gate;
}


/*
 * find_pin_slot:
 * Description:
 * 	Helper function that finds an empty pin slot for usage.
 * Input:
 * 	struct gate * variable;
 * Return Value:
 * 	Pin number on successful run, '-1' on failure.
 */
static int find_pin_slot(struct gate *gate)
{
	int current_pin;

	if (ARE_PINS_SET(gate)) {
		/* fprintf(stderr, "Error in Gate %s: All pins set.\n", gate->name); */
		return -1;
	}

	if (gate->unset_slots != NULL) {
		current_pin = *((int *) slist_data(gate->unset_slots));

		/* free malloced pin number in unset pins */
		free(slist_data(gate->unset_slots));
		slist_remove_entry(&gate->unset_slots, gate->unset_slots);
	} else {
		do {
			current_pin = gate->current_pin++;
		} while (gate->pins[current_pin].type != NUL
				&& current_pin < gate->total_pins);
	}

	return current_pin;
}


/*
 * get input by reading from stdin and set it to the current pin.
 * Usage: get_input(a1);
 */
/* void get_input(struct gate *gate) */
/* { */
/* 	int current_pin; */

/* 	if ((current_pin = find_pin_slot(gate)) == -1) */
/* 		return; */

/* 	int holder; */
/* 	printf("[%s, %s] Pin(%d)%s ", gate_names[gate->class], gate->name, */
/* 			current_pin, ">>>"); */
/* 	scanf("%d", &holder); */

/* 	if (holder != 0 && holder != 1) */
/* 		fprintf(stderr, "%d will be considered true.\n", holder); */

/* 	gate->pins[current_pin].ip.pin = holder; */
/* 	gate->pins[current_pin].type = INTERNAL; */
/* } */


int set_pin(struct gate *gate, bool truth)
{
	int current_pin;

	if ((current_pin = find_pin_slot(gate)) == -1)
		return -1;

	gate->pins[current_pin].ip.pin = truth;
	gate->pins[current_pin].type = INTERNAL;
	gate->set_pins++;

	return current_pin;
}

int unset_pin(struct gate *gate, int pin_number)
{
	if (gate == NULL || gate->pins[pin_number].type == NUL
		|| pin_number < 0 || pin_number >= gate->total_pins)
		return 0;

	int *x = malloc(sizeof(int));
	*x = pin_number;

	gate->pins[pin_number].type = NUL;
	slist_prepend(&gate->unset_slots, x);
	gate->set_pins--;

	return 1;
}


void short_pins(struct gate *dst, int dst_pin, struct gate *src, int src_pin, char type)
{

	/* ERROR handling, hehe, more like error avoiding. */
	if (src == NULL || dst == NULL) {
		fputs("Pass a valid pointer.\n", stderr);
		return;
	}

	if ((type) != SHORT_OUT && (type) != SHORT_IN) {
		fputs("Unknown type specified.\n", stderr);
		return;
	}

	if (src == dst) {
		fputs("WARNING: you are shorting the port to itself,"
				" let me snatch that freedom from you.\n", stderr);
		return;
	}

	if (src_pin >= src->total_pins) {
		fprintf(stderr, "Error: 'src' pin number out of range."
				"Pin number should be in the range [0...%lu]"
				"(exclusive).\n", src->total_pins);
		return;
	}

	if (dst_pin >= dst->total_pins) {
		fprintf(stderr, "Error: 'dst' pin number out of range."
				"Pin number should be in the range [0...%lu]"
				"(exclusive).\n", dst->total_pins);
		return;
	}
	/* woof, we're safe. */

	dst->pins[dst_pin].ip.from.gate = src;
	dst->pins[dst_pin].ip.from.pin = src_pin;
	dst->pins[dst_pin].type = type;

	dst->set_pins++;
}


/*
 * perofrm the 'or' operation on a given gate and return it's result to be
 * processed by calculate_output.
 */
static bool or_op(Or gate)
{
	bool truth = false;
	for (int i = 1; i < gate->total_pins; ++i)
		truth |= get_pin_value(gate, i);
	return truth;
}


/*
 * same as the above function except it performs 'and' operation.
 */
static bool and_op(And gate)
{
	bool truth = true;

	for (int i = 1; i < gate->total_pins; ++i)
		truth &= get_pin_value(gate, i);

	return truth;
}


/*
 * similarly, perform 'xor' and return it's result for processing.
 */
static bool xor_op(Xor gate)
{
	bool truth = false;

	for (int i = 1; i < gate->total_pins; ++i)
		truth ^= get_pin_value(gate, i);
	return truth;
}


/*
 * only calculates the gate output when all the inputs are set. Default case is
 * return faulty value.
 */
static bool calculate_output(struct gate* gate)
{
	if (!ARE_PINS_SET(gate))
		return false;

	bool truth = get_pin_value(gate, 0);

	if (gate->class == AND)
		truth &= and_op(gate);
	else if (gate->class == OR)
		truth |= or_op(gate);
	else if (gate->class == NOT)
		truth = !truth;
	else if (gate->class == XOR)
		truth ^= xor_op(gate);
	else if (gate->class == XNOR)
		truth = !(truth ^ xor_op(gate));
	else if (gate->class == NOR)
		truth = !(truth | or_op(gate));
	else if (gate->class == NAND)
		truth = !(truth & and_op(gate));
	else { // almost no chance of getting here.(unless the library is modified)
		fprintf(stderr, "Unknown gate class.\n");
		truth = false;
	}

	return truth;
}


/*
 * 	Calls calculate_output() to perform the logic and sets the
 * 	result of the call to the output pin(gate->op) of the given gate.
 */
bool get_output(struct gate *gate)
{
	bool output;

	output = calculate_output(gate);
	gate->op = output;

	return output;
}


bool get_pin_value(struct gate *gate, int pin_number)
{
	/* this is a bad way to handle errors. as there is no way to
	 * differentiate between false values in gate and false returned due to
	 * this exception.  TO-DO #2.
	 */
	if (gate == NULL || gate->pins[pin_number].type == NUL)
		return false;

	if (gate->pins[pin_number].type == INTERNAL)
		return gate->pins[pin_number].ip.pin;
	else if (gate->pins[pin_number].type == SHORT_OUT) {
		return get_output(gate->pins[pin_number].ip.from.gate);
	} else {
		int next_pin = gate->pins[pin_number].ip.from.pin;
		return get_pin_value(gate->pins[pin_number].ip.from.gate, next_pin);
	}
}


/* ginfo (gate info) functions to see/peek into gate's members.
 */

size_t ginfo_capacity(struct gate *gate)
{
	return gate ? gate->total_pins : 0;
}

short ginfo_class(struct gate *gate)
{
	return gate ? gate->class : -1;
}


char *ginfo_tag(struct gate *gate)
{
	if (!gate)
		return NULL;

	size_t len = strnlen(gate->name, 80) + 1; /* for the NUL byte */
	char *tag = calloc(len, sizeof(char));
	if (!tag)
		return NULL;

	strncpy(tag, gate->name, len);
	return tag;
}


bool ginfo_is_pin_set(struct gate *gate, int pin)
{
	return gate && gate->pins[pin].type != NUL;
}
