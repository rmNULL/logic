/*
 * gates.c: Implementation of gates.h header.
 * @author: rmNULL
 * Version: 0.10
 * LICENSE: MIT, refer LICENSE for more.
 * Description: see README.
 */
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ds/slist.h"
#include "gates.h"

/* default gate input method */
#define NUL '\0'

#define TAG_LEN 31

struct gate_input_t {
	union {
		bool pin;

		struct {
			struct gate *gate;
			int pin;
		} from;
	} ip;
	char type;
};

struct gate {
	char *name;
	int class;

	int current_pin;
	size_t set_pins;
	size_t total_pins;
	struct gate_input_t *pins;

	/* keeps track of unpinned slots. */
	SListEntry *unset_slots;

	bool op;
};

/*
 * let user deal with failed memory allocations.
 */
#define ALLOC_WITH_FAILURE_HANDLE(ptr, size) do {\
	(ptr) = malloc(size); \
	if ((ptr) == NULL) { \
		return NULL; \
	}\
} while(0)

/* checks if all the input pins of the given gate are set. */
#define ARE_PINS_SET(gate) ((gate->set_pins) == (gate->total_pins))

/* destructor */
void cleanup(struct gate *const gate)
{
	if (gate == NULL)
		return;

	while (gate->unset_slots) {
		free(slist_data(gate->unset_slots));
		slist_remove_entry(&gate->unset_slots, gate->unset_slots);
	}

	if (gate->name) free(gate->name);
	if (gate->pins) free(gate->pins);
	if (gate) free(gate);
}


/* mdfn: macro defined function(s).
 * macro to (auto) define functions for creation of gates.
 *
 * defines a function with gatename as the return type and taking total_ip_pins
 * as the argument; Minimum of 2 input pins need to be present. Returns NULL on
 * allocation failure.
 */
#define mdfn(gatename, cls) \
gatename create_##gatename##_gate(const char *tag, size_t total_ip_pins) { \
	gatename gate;\
	if (total_ip_pins < 2 || total_ip_pins > 64) {\
		fprintf(stderr, "Error: Unable to create [%s %s] gate.", tag, gate_names[cls]);\
		fprintf(stderr, " %lu not in range [2..64].\n", total_ip_pins);\
		return NULL;\
	}\
	ALLOC_WITH_FAILURE_HANDLE(gate, sizeof(struct gate));\
	ALLOC_WITH_FAILURE_HANDLE(gate->pins, sizeof(struct gate_input_t) * total_ip_pins); \
	gate->total_pins = total_ip_pins; \
	gate->op = false; \
	gate->current_pin = 0; \
	gate->set_pins = 0;\
	gate->unset_slots = NULL;\
	gate->class = cls;\
	/*
	 * let all the gates have no type(NUL) by default. This is done
	 * to safeguard the shorted input pins. At the cost of checking at
	 * every assignment.
	 */ \
	for (int i = 0; i < total_ip_pins; ++i) { \
		gate->pins[i].type = NUL; \
	}\
	size_t len = strnlen(tag, TAG_LEN) + 1; /* +1 for the NUL byte. */ \
	ALLOC_WITH_FAILURE_HANDLE(gate->name, sizeof(char) * len);\
	strncpy(gate->name, tag, len);\
	return gate; \
}

/*
 * Semi-colons are not suffixed to maintain compatibilty with ISO C(sorry).
 *
 * e.g: defines a function for creating And gate of the form, (And Gate Example)
 *  Æ’: And create_And_gate(char *gate_name, size_t total_ip_pins);
 */
mdfn(And, AND)
mdfn(Or, OR)
mdfn(Xor, XOR)
mdfn(Xnor, XNOR)
mdfn(Nor, NOR)
mdfn(Nand, NAND)
#undef mdfn

/*
 * This function is not auto-generated by mdfn(macro) because
 * Not gate stands out from the crowd as it doesn't have variable number of
 * input pins. Maybe do a dirty hack and patch it in there, maybe?
 */
Not create_Not_gate(const char *tag)
{
	/* TODO. here one extra memory block is allocated for input slot which is
	 * never used, this kind of memory abuse is a sign of bad programming
	 * and should be overcome. */
	Not gate = create_And_gate(tag, 2);
	gate->total_pins = 1;
	gate->class = NOT;

	return gate;
}


/*
 * find_pin_slot:
 * Description:
 * 	Helper function that finds an empty pin slot for usage.
 * Input:
 * 	struct gate * variable;
 * Return Value:
 * 	Pin number on successful run.
 * 	'-1' when an invalid gate is passed.
 * 	'-2' when no empty slots.
 */
static int find_pin_slot(struct gate *const gate)
{
	int current_pin;

	if (gate == NULL)
		return -1;

	if (ARE_PINS_SET(gate)) {
		return -2;
	}

	if (gate->unset_slots != NULL) {
		current_pin = *((int *) slist_data(gate->unset_slots));

		/* free malloced pin number in unset pins */
		free(slist_data(gate->unset_slots));
		slist_remove_entry(&gate->unset_slots, gate->unset_slots);
	} else {
		do {
			current_pin = gate->current_pin++;
		} while (gate->pins[current_pin].type != NUL
				&& current_pin < gate->total_pins);
	}

	return current_pin;
}


int set_pin(struct gate *const gate, bool truth)
{
	int current_pin;

	if ((current_pin = find_pin_slot(gate)) == -1
		|| current_pin == -2)
		return current_pin;

	gate->pins[current_pin].ip.pin = truth;
	gate->pins[current_pin].type = INTERNAL;
	gate->set_pins++;

	return current_pin;
}

int unset_pin(struct gate *const gate, int pin_number)
{
	if (gate == NULL || gate->pins[pin_number].type == NUL
		|| pin_number < 0 || pin_number >= gate->total_pins)
		return 0;

	int *x = malloc(sizeof(int));
	*x = pin_number;

	gate->pins[pin_number].type = NUL;
	slist_prepend(&gate->unset_slots, x);
	gate->set_pins--;

	return 1;
}


void short_pins(struct gate *const dst, int dst_pin,
		struct gate *const src, int src_pin,
		char type)
{

	/* ERROR handling, hehe, more like error avoiding. */
	if (src == NULL || dst == NULL) {
		fputs("Pass a valid pointer.\n", stderr);
		return ;
	}

	if ((type) != SHORT_OUT && (type) != SHORT_IN) {
		fputs("Unknown type specified.\n", stderr);
		return;
	}

	if (src == dst) {
		fputs("WARNING: you are shorting the port to itself,"
				" let me snatch that freedom from you.\n", stderr);
		return;
	}

	if (src_pin >= src->total_pins) {
		fprintf(stderr, "Error: 'src' pin number out of range."
				"Pin number should be in the range [0...%lu]"
				"(exclusive).\n", src->total_pins);
		return;
	}

	if (dst_pin >= dst->total_pins) {
		fprintf(stderr, "Error: 'dst' pin number out of range."
				"Pin number should be in the range [0...%lu]"
				"(exclusive).\n", dst->total_pins);
		return;
	}
	/* woof, we're safe. */

	dst->pins[dst_pin].ip.from.gate = src;
	dst->pins[dst_pin].ip.from.pin = src_pin;
	dst->pins[dst_pin].type = type;

	dst->set_pins++;

	/* return 0; */
}


/* logic function generator. */
#define define_op_fn(logic_name, sym) \
static int logic_name##_op(const struct gate *gate) \
{\
	if (gate == NULL)\
		return -1;\
	\
	bool truth = get_pin_value(gate, 0);\
	\
	for (int i = 1; i < gate->total_pins; ++i)\
		truth sym##= get_pin_value(gate, i);\
	\
	return truth;\
}\

define_op_fn(and, &)
define_op_fn(or, |)
define_op_fn(xor, ^)
#undef define_op_fn

/* inverted function generator. */
#define define_op_fn(logic_name, base_op) \
static int logic_name##_op(const struct gate *gate) \
{\
	int truth = base_op;\
	return truth == -1 ? truth : !truth;\
}\

define_op_fn(not, get_pin_value(gate, 0))
define_op_fn(nor, or_op(gate)) 
define_op_fn(nand, and_op(gate))
define_op_fn(xnor, xor_op(gate))

#undef define_op_fn
/* end of generated functions */


/*
 * only calculates the gate output when all the inputs are set. Default case is
 * return faulty value.
 */
static bool calculate_output(struct gate *gate)
{
	if (gate == NULL || !ARE_PINS_SET(gate))
		return false;

	bool truth =
		gate->class == OR   ?   or_op(gate) :
		gate->class == AND  ?  and_op(gate) :
		gate->class == NOT  ?  not_op(gate) :
		gate->class == NOR  ?  nor_op(gate) :
		gate->class == XOR  ?  xor_op(gate) :
		gate->class == XNOR ? xnor_op(gate) :
		gate->class == NAND ? nand_op(gate) :
		false;

	return truth;
}


/*
 * 	Calls calculate_output() to perform the logic and sets the
 * 	result of the call to the output pin(gate->op) of the given gate.
 */
bool get_output(struct gate *gate)
{

	bool output = calculate_output(gate);
	gate->op = output;

	return output;
}


int get_pin_value(const struct gate *gate, int pin_number)
{
	/* this is a bad way to handle errors. as there is no way to
	 * differentiate between false values in gate and false returned due to
	 * this exception.  TO-DO #2.
	 */
	if (gate == NULL)
		return -1;

	if (gate->pins[pin_number].type == NUL)
		return -2;

	if (gate->pins[pin_number].type == INTERNAL)
		return gate->pins[pin_number].ip.pin;
	else if (gate->pins[pin_number].type == SHORT_OUT) {
		return get_output(gate->pins[pin_number].ip.from.gate);
	} else {
		int next_pin = gate->pins[pin_number].ip.from.pin;
		return get_pin_value(gate->pins[pin_number].ip.from.gate, next_pin);
	}
}


/*
 * ginfo (gate info) functions to peek into gate's members.
 */
size_t ginfo_capacity(const struct gate *const gate)
{
	return gate ? gate->total_pins : -1;
}

short ginfo_class(const struct gate *const gate)
{
	return gate ? gate->class : -1;
}

char *ginfo_tag(const struct gate *const gate)
{
	if (gate == NULL)
		return NULL;

	size_t len = strnlen(gate->name, TAG_LEN) + 1; /* for the NUL byte */
	char *tag = calloc(len, sizeof(char));
	if (!tag)
		return NULL;

	strncpy(tag, gate->name, len);
	return tag;
}


bool ginfo_is_pin_set(const struct gate *const gate, int pin)
{
	return gate && gate->pins[pin].type != NUL;
}
